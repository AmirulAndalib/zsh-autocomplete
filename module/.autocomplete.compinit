#!/bin/zsh

.autocomplete.compinit.precmd() {
  emulate -L zsh -o extendedglob
  add-zsh-hook -d precmd .autocomplete.compinit.precmd

  typeset -g _comp_dumpfile=${_comp_dumpfile:-${ZSH_COMPDUMP:-$XDG_CACHE_HOME/zcompdump}}
  if [[ -z $functions[_autocomplete.extras] ]]; then
    if [[ -e $_comp_dumpfile ]]; then
      # Decrease Oh My Zsh start-up time. See below.
      [[ $_comp_dumpfile == $ZSH_COMPDUMP ]] &&
        local -a omzdump=( ${(f)"$(<$ZSH_COMPDUMP)"} )

      local -a newest=( $^fpath/***/_*(Nom) )
      if [[ $newest[1] -nt $_comp_dumpfile ]]; then
        zmodload -F zsh/files b:zf_rm
        zf_rm -f $_comp_dumpfile
      fi
    fi
    () {
      zmodload zsh/complist
      unfunction compinit 2>/dev/null
      builtin autoload -Uz compinit
      compinit -C -d $_comp_dumpfile
      local bin=$_comp_dumpfile.zwc
      if [[ ! -e $bin || $bin -ot $_comp_dumpfile ]]; then
        zcompile -Uz $_comp_dumpfile
      fi
    }

    # Prevent Oh My Zsh from deleting comp dump file.
    [[ $_comp_dumpfile == $ZSH_COMPDUMP ]] &&
      tee -a "$ZSH_COMPDUMP" &>/dev/null <<EOF
$omzdump[-2]
$omzdump[-1]
EOF
  fi

  local src bin cache_dir;
  zstyle -s ':completion:*' cache-path cache_dir && () {
    for src in $cache_dir/*~*.zwc(N-.); do
      bin=$src.zwc
      if [[ ! -e $bin || $bin -ot $src ]]; then
        zcompile -Uz $src
      fi
    done
  }

  local args; for args in $_autocomplete__compdef[@]; do
    compdef "${(z@)${(Q)args}}"
  done

  _comp_options+=(
    functionargzero globdots globstarshort numericglobsort
    NO_alwaystoend NO_caseglob NO_completealiases
    NO_globcomplete NO_listbeep NO_listtypes NO_markdirs
  )

  .autocomplete.compadd() {
    if [[ $_completer == expand* ]]; then
      builtin compadd -f -W "${${${words[CURRENT]:#[~/]*}:+$PWD/}:-/}" "$@"
    else
      builtin compadd "$@"
    fi
  }

  builtin autoload -Uz .autocomplete.patch

  .autocomplete.patch _main_complete
  _main_complete() {
    local word=$PREFIX$SUFFIX
    local _autocomplete__tail=${word##*/}
    local _autocomplete__head=${word%%$_autocomplete__tail}
    local _autocomplete__alnum=${_autocomplete__tail##[^[:alnum:]]##}
    local _autocomplete__punct=${_autocomplete__tail%%$_autocomplete__alnum}

    local -i _autocomplete__reserved_lines=0

    local +h -a comppostfuncs=(
      _autocomplete.extras
      "$comppostfuncs[@]"
    )
    compstate[insert]='menu'
    {
      # Don't break `_complete_help` widget.
      [[ -v functions[compadd] ]] ||
        functions[compadd]=$functions[.autocomplete.compadd]

      .autocomplete._main_complete "$@"

    } always {
      # Don't break `_complete_help` widget.
      [[ $functions[compadd] == $functions[.autocomplete.compadd] ]] &&
        unfunction compadd
    }
    typeset -gHi _autocomplete__current=$CURRENT
    typeset -gH _autocomplete__words="$words"
    compstate[list_max]=0
    (( compstate[nmatches] > 0 ))
  }

  .autocomplete.patch _description
  _description() {
    .autocomplete._description "$@"; local -i ret=$?
    _lastdescr=( ${(@)_lastdescr[@]:#(corrections|history word)} )
    [[ -n $_autocomplete__head ]] &&
      _lastdescr=( ${(@)_lastdescr[@]:#recent directory} )
    return ret
  }

  .autocomplete.patch _path_files
  _path_files() {
    .autocomplete._path_files "$@"; local -i ret=$?
    _autocomplete.recent_paths
    return ret
  }

  .autocomplete.patch _complete
  _complete() {
    local -i nmatches=$compstate[nmatches]
    .autocomplete._complete "$@"

    (( compstate[nmatches] > nmatches )) &&
      return 0

    _comp_mesg=''
    return 1
  }

  .autocomplete.builtin() {
    [[ -v functions[builtin] ]] &&
      unfunction builtin
    {
      if [[ $1 == compadd && $funcstack[2] == compadd ]]; then
        shift $(( $#_correct_expl[@] + 1 ))
        builtin compadd "$@"
      else
        builtin "$@"
      fi
    } always {
      functions[builtin]=$functions[.autocomplete.builtin]
    }
  }

  .autocomplete.patch _approximate
  .autocomplete.patch _correct
  _approximate _correct () {
    [[ -z $words[CURRENT] ]] &&
      return 1
    [[ -v compstate[quote] ]] &&
      return 1
    [[ -o banghist && $words[CURRENT] == [$histchars]* ]] &&
      return 1
    _autocomplete.is_glob &&
      return 1

    local -i ret=1
    {
      [[ $functions[compadd] == $functions[.autocomplete.compadd] ]] &&
        unfunction compadd
      functions[builtin]=$functions[.autocomplete.builtin]

      .autocomplete.$0 "$@"; ret=$?

    } always {
      [[ -v functions[builtin] ]] &&
        unfunction builtin
      functions[compadd]=$functions[.autocomplete.compadd]
    }
    return ret
  }

  .autocomplete.patch _expand
  _expand() {
    if _autocomplete.is_glob && [[ $WIDGET != _complete_help ]]; then
      [[ $words[CURRENT] == *[^*] ]] &&
        local ISUFFIX="*"
    fi
    .autocomplete._expand "$@"
  }
}

add-zsh-hook precmd .autocomplete.compinit.precmd
