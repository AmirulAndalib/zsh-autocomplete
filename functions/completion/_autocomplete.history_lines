#autoload

_autocomplete.history_lines() {

  # Don't run more than once.
  [[ _matcher_num -eq 1  ]] ||
      return

  local -P lbuffer='' rbuffer=''
  [[ $CURRENT -gt 1 ]] &&
      lbuffer="${(j.[[:blank:]]##.)${(@b)words[1,CURRENT-1]}}[[:blank:]]##"
  [[ $CURRENT -lt $#words[@] ]] &&
      rbuffer="[[:blank:]]##${(j.[[:blank:]]##.)${(@b)words[CURRENT+1,-1]}}"
  lbuffer="$lbuffer${(b)QIPREFIX}"
  rbuffer="${(b)QISUFFIX}$rbuffer"

  local -P query=''
  if [[ -z $words[CURRENT] ]]; then
    query='*'
  else
    local -P pre='' post='' no_delim='[^\n;]#'
    if [[ -z $lbuffer ]]; then
      pre='*'
    else
      pre=$no_delim
    fi
    if [[ -z $rbuffer ]]; then
      post='*'
    else
      post=$no_delim
    fi
    pre="$pre(#l)"
    post="(#I)$post"

    local -Pa includes=( "${(@s..b)^words[CURRENT]}" )
    local -Pa excludes=( "(|[^${(@s..b)^words[CURRENT]}\n;]#)" )
    local -Pa tokens=( ${(@)excludes:^includes} )

    query="$pre($tokens[2]${(j..)tokens[3,-1]})$post"
  fi

  [[ $curcontext != *-incremental-* ]] &&
      zle -R 'Loading...'

  local -P out="$( fc -lrm "$lbuffer$query$rbuffer" -1 1 2> /dev/null )"

  # No results
  [[ -n $out ]] ||
      return

  local -aU displays=( "${(f)out}" )

  local -P numpat='[[:space:]]#(<->)[* ] '
  local -P dim='=2' default='=0' highlight='=30;103'
  _comp_colors=(
      "=(#b)$numpat($lbuffer)$query($rbuffer)$default$dim$highlight$highlight${(pr.$((
          $#default * $#words[CURRENT]
      ))..$default.):-}$highlight"
      "=(#b)$numpat($lbuffer)$query*$default$dim2$highlight$highlight"
      "=(#b)$numpat($lbuffer)*$default$dim$highlight"
      "=(#b)$numpat*$default$dim"
      ${(M)_comp_colors:#ma=*}
  )

  local -Pi list_lines=0
  if ! builtin zstyle -s ":autocomplete:${curcontext}:" list-lines list_lines; then
    list_lines=16
    [[ $curcontext != *-incremental-* ]] &&
        list_lines=$(( 16 * list_lines ))
  fi
  [[ $curcontext == *-incremental-* ]] &&
      list_lines=$(( min( list_lines, LINES - BUFFERLINES - 1 ) ))

  if [[ -o histfindnodups ]]; then
    local -Pa uniques=()
    while (( $#displays[@] && $#uniques[@] < list_lines )); do
      (( uniques[(I)$~numpat${output[1]##$~numpat}] )) ||
          uniques+=( "$output[1]" )
      shift displays
    done
    displays=( "$uniques[@]" )
  else
    [[ $#displays[@] -gt $list_lines ]] &&
        shift $(( $#displays[@] - list_lines )) displays
  fi

  if [[ $curcontext == *-incremental-* ]]; then
    if [[ -z $words ]]; then
      displays=( ${(@aO)displays} )
    else
      local -a match=() mbegin=() mend=()
      local MATCH= MBEGIN= MEND=
      displays=(
          ${(@nO)displays[@]:/(#b)($~numpat$~lbuffer$~query*)/$((
            match[2] - mbegin[3] - $#match[3]
          ))$'\0'$match[1]}
      )
      displays=( ${displays[@]#<->$'\0'} )
    fi
  fi

  displays=( ${(@r:COLUMNS-1:)displays} )

  local -Pa matches=()
  local -Pi index=0
  for index in "${(MS)displays[@]##<->}"; do
    matches+=( "${${history[$index]##$~lbuffer}%%$~rbuffer}" )
  done

  local -Pa suf=()
  local -a expl=()
  local _comp_no_ignore=1
  if [[ $#words[@] -eq $CURRENT && $WIDGETSTYLE == *-select* ]]; then
    suf=( -S ';' -R _autocomplete.history_lines.suffix )
  else
    suf=( -qS ' ' )
  fi

  _comp_tags=history-lines
  _description -2V $_comp_tags expl ''
  builtin compadd "$expl[@]" $suf -QU -ld displays -a matches
}

_autocomplete.history_lines.suffix() {
  [[ $KEYS[-1] != $'\C-@' ]] &&
      LBUFFER=$LBUFFER[1,-1-$1]
}

_autocomplete.history_lines "$@"
